---
index: 1
title: React项目中的常见优化方案总结
description: 这篇文章，介绍了一些 React 项目里面，比较常见的优化方案，希望对您也有用 😃
author: 杨飞
tags: [react, 优化]
date: 2024-02-22 08:42:39
---

> 注意: 优化不要变成, 为了优化而优化！优化应该在项目有变慢迹象的时候去做。其他时候，按规范开发，稍加注意即可，不用过于刻意。

### 一、代码层面

#### 1、组件优化

- 使用 `React.memo` 包裹子组件，避免不必要的渲染。

- 避免在渲染方法中，定义新的对象或函数，以防止不必要的组件重渲染。
  > - 将他们移动到渲染方法的外部定义即可。
  > - 对于`有复杂处理逻辑的函数`或者`作为参数被传递的函数`，使用`useCallback`钩子来优化。
  >   > 因为被传递的函数, 在组件渲染的时候，会被重新创建，所以作为参数使用的时候，需要使用`useCallback`钩子处理。

- 避免在渲染方法中使用: `对象字面量`、`匿名函数`。因为每次渲染的时候，都会被视为新创建的，从而导致组件重渲染。

  > 对象字面量优化策略：
    >   - 将对象字面量，移动到组件的外部，变成一个外部常量。
    >   - 使用`useMemo`钩子，依赖项没有发生变化的时候，值对于 react 来说就是一个没有变化的值，不会引起重新渲染。

  > 匿名函数就改成，在渲染方法的外部创建一个新的命名函数。

#### 2、Hooks 优化
> 对于一些逻辑非常简单的函数或者计算，不要使用 `hooks` 来优化，因为这些 `hook` 本身运行就有一定的成本。用了就是`反向优化`了。。。

- 使用 `useCallback` 钩子缓存回调函数，避免在每次渲染时都创建新的函数。
- 使用 `useMemo` 钩子缓存计算成本较高的结果。
- 正确使用依赖数组，只在依赖项变化时才重新计算或执行副作用。

#### 3、状态管理

- 对于多个组件需要的数据，应该使用`状态提升`的策略，把数据提升到更高的层级来管理。
- `状态提升`不要变成`数据长征`，如果一个数据，需要传递太多的组件层级，或者需要传递的层级关系非常复杂。那么你应当使用全局状态管理，如: `redux`、`mobx`、`jotai`等等.

> 状态提升（Lifting State Up）是 React 中的一个常用模式，指的是将子组件的状态移至它们共同的父组件中管理。这样做是为了能够在多个子组件之间共享和操作同一状态。在父组件中管理状态后，该状态就可以作为 props 传递给需要它的子组件。这样，子组件就能够同步更新，并且保持一致性。

#### 4、列表渲染优化

- 列表的每一个元素，都应当有一个唯一的`key值`，帮助`react`识别哪些列表项发生了变化。`key值`应当和元素关联，不推荐把`索引值`当成`key值`（纯展示的静态元素[没有增删改]可以使用`索引值`作为`key值`）。
- 使用`虚拟列表技术`来渲染长列表。常见的虚拟列表技术有:`react-window`、`react-virtualized`、`react-virtuoso`等等。
  > 本站使用了`react-virtuoso`来渲染长列表

#### 5、防抖和节流

- 对于提交按钮类的操作，例如表单提交按钮，为了有一个相对较好的用户体验，一般使用防抖`debounce`策略来处理，比如，提交后 1 秒内，反复点击也不会响应提交请求。尤其是秒杀类场景的提交按钮，用户一定是会疯狂点击的。
- 节流`throttle`，比较常见的场景是对页面滚动、窗口缩放等事件, 进行监听的时候。因为频率异常高，所以我们需要进行节流，降低事件处理的频率。

#### 6、减少外部库依赖

- 按需加载第三方库，尽量不要使用全量引入的方式使用第三方库。
- 可能得情况下，选中体积更小，定制化更方便的第三方库。比如：我以前用 `antd`, 不按需加载，打包体积会很大。现在我使用 `shadcn` 打包体积远小于 `antd`.

#### 7、使用不可变数据结构

  使用不可变数据类型，可以帮助避免不必要的数据变动和重新渲染。如: `Immutable.js`、`immer.js`, `Redux Toolkit`在内部自动使用了`immer`.

#### 8、web workers

- 对于前端需要计算处理的复杂任务，可以使用`web worker`在后台进行处理，避免页面阻塞。
- 一般来说，我们尽量避免把复杂计算放在前端，毕竟前端的算力天花板很低，除非是后端无法执行的任务（如:没有能力处理、数据无法控制等等异常场景。。。）


### 二、资源层面

#### 1、合理的代码分割

  > 页面加载的时候, 如果页面过大，会加载的非常慢，这种场景下，就应该对页面的代码进行分割。

  - 使用动态`import()`语法进行代码分割，将代码拆分为独立的块`chunks`，按需加载（非首屏渲染组件，一般都要动态加载）。
  - 使用 `React.lazy` 和 `Suspense` 来实现组件层面的懒加载。

#### 2、资源懒加载

  > 静态资源资源，可以实现懒加载，在资源进入可视范围的时候才加载。

  - 使用原生的`loading`属性，主流浏览器基本都已经支持这个新特性。
    ```html
    <img src="path-to-image.jpg" loading="lazy" alt="Description" />
    ```
  - 使用`JavaScript`监听滚动事件，计算元素的位置，判断是否在可视范围内。
  - 使用`Intersection Observer API`, 它提供了一种异步检测目标元素与其祖先元素或顶级文档视窗（viewport）交叉状态的方法.

#### 3、预加载和预读取

- 使用 `<link rel="preload" />` 指令预加载关键资源

  - 一些例子:
    ```html
      <!-- 预加载CSS文件 -->
      <link rel="preload" href="styles.css" as="style">
      <!-- 预加载JavaScript文件 -->
      <link rel="preload" href="script.js" as="script">
      <!-- 预加载字体文件-->
      <link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin="anonymous">
      <!-- 预加载图片文件-->
      <link rel="preload" href="image.png" as="image">
    ```
  - 需要注意的点:
    >  - 资源类型：使用as属性来指定资源的类型。这对于浏览器正确处理预加载请求很重要，例如，知道资源是图片、样式表还是脚本。
    >  - 跨域：如果资源是跨域的，需要加上crossorigin属性。对于字体文件这尤其重要，因为字体通常要求跨域请求必须经过授权。
    >  - 性能考量：不应过度使用 `<link rel="preload">`，因为虽然它可以加快特定资源的加载速度，但过度预加载可能会消耗用户的数据带宽，并可能引起浏览器的资源竞争。
    >  - 使用 `<link rel="preload">` 的最佳实践是对关键路径（critical path）上的资源进行优先加载，即那些阻塞渲染的资源，以尽快地让网页可交互。

- 对于非关键资源，可以使用 `<link rel="prefetch" />` 提前请求资源以供后续使用。
  > 请注意，因为 prefetch 是在浏览器空闲时进行的，所以它的实际效果可能受到用户的网络条件和浏览器状态的影响。

  - 一些例子:
    ```html
      <!-- HTML -->
      <link rel="prefetch" href="next-page.html">
      <!-- 图像  -->
      <link rel="prefetch" href="hover-image.png">
      <!-- css -->
      <link rel="prefetch" href="next-page-styles.css">
      <!-- js -->
      <link rel="prefetch" href="next-page-script.js">
    ```
  - 最佳实践:
    > - 预取次级页面：如果你知道用户很可能会访问某个特定的页面（例如，从首页到登录页），可以预取那个页面的关键资源。
    > - 不要过度使用：虽然 prefetch 是低优先级的，但仍然不应该过多使用，以免消耗用户的数据并占用不必要的带宽。
    > - 策略性使用：结合使用者的数据和行为模式来选择哪些资源应该被预取。

#### 4、渲染模式

对于一些对页面加载速度有高要求的页面，比如官网，这种我们可以使用类似 `next` 这样的服务端渲染框架，使用`SSR`或者`SSG`的渲染模式来加速用户体验。

#### 5、网络请求优化

- 减少不必要的 `api` 调用，尽可能合并请求到一个接口。
- 多个资源请求，应当并发获取，而非顺序请求。
- 可以使用 `graphQL` 来获取准确的数据，不必获取太多不必要的数据。

#### 6、使用 CDN 分发静态资源

`CDN`可以显著的提升资源的访问速度。

#### 7、资源优化

- 使用 `PurifyCSS` 或者类似的工具来移除未使用的`CSS`。
- 使用现代图片格式，如 `WebP`，这通常可以比传统的图片格式提供更小的文件大小和更好的性能。

#### 8、数据压缩

- `图片`、`js`、`css`等资源应该压缩文件大小，降低网络负载。打包构建工具有很多相关的库，可以供我们使用。
- web代理服务，比如: `nginx`服务, 应该开启 `gzip`或者类似的压缩机制。

### 三、说明

优化方法千千万，不同的项目，遇到的问题也不尽相同。千万不要生搬硬套各种优化方案，选则适合你的才重要，否则很容易变成，为了优化而优化。

这里总结的只是一部分常见的优化项目，如果你有比较好的优化方案，而且也愿意，一起分享给大家，欢迎联系我补充 😃

感谢阅读，祝您有个好心情~！
